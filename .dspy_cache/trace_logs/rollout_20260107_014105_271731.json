{
  "rollout_id": "rollout_20260107_014105_271731",
  "timestamp": "2026-01-07T01:42:30.245607",
  "instruction": "# Backend Engineering: cc-mirror State Bridge Adapter\n\n## Core Mandates\n1. **Lazy Loading:** SessionDiscovery returns metadata only; parse content on-demand.\n2. **Resilient Parsing:** Try known formats first (v1, v2), then generic heuristic fallback.\n3. **Token Budget:** Context injection limited to ~12.5K tokens; truncate/summarize gracefully.\n\n## Configuration & Standards\n- **Dependencies:** `google-auth-library`, `keytar`, `fs-extra`, `node-fetch`\n- **Storage:** OAuth tokens in `~/.cc-mirror/antigravity-tokens/{email}.enc`\n- **Encryption:** AES-256-GCM with OS keychain key storage\n\n## Performance Targets\n| Operation | Target |\n|-----------|--------|\n| Session discovery (100 files) | <50ms |\n| Session parse (<1MB) | <100ms |\n| Context injection | <20ms |\n| End-to-end | <500ms (p90) |\n\n## API Transformation\n- Anthropic messages \u2192 Google Gen AI `contents`\n- System messages \u2192 consolidated `systemInstruction`\n- Tool hardening: 4-layer Mirrowel pattern",
  "story_context": "---\nid: \"20260107_session_parser\"\ndifficulty: \"hard\"\ntags: [\"state-bridge\", \"parsing\", \"json\", \"typescript\", \"resilience\"]\ntech_stack: \"Node.js 18+, TypeScript 5.x\"\n---\n\n# User Story\nAs a developer, I want cc-mirror to parse Antigravity session files reliably, so I can get my work context even if AG's format changes.\n\n# Context & Constraints\n**Interface Requirements (SessionParser):**\n```typescript\ninterface SessionParser {\n  parse(filePath: string): Promise<ParsedSession>;\n  registerFormat(detector: FormatDetector): void;\n}\n\ninterface ParsedSession {\n  sessionId: string;\n  goal: string;\n  planSteps: PlanStep[];\n  currentStep: number;\n  completedSteps: PlanStep[];\n  pendingSteps: PlanStep[];\n  filesModified: string[];\n  variables: Record<string, any>;\n}\n\ninterface PlanStep {\n  id: string;\n  action: string;\n  status: 'pending' | 'executing' | 'completed' | 'failed';\n  artifacts?: string[];\n}\n```\n\n**Format Detection Strategy:**\n1. Try known format v1 (legacy)\n2. Try known format v2 (current)\n3. Fallback to generic heuristic parser\n\n**Constraints:**\n| Constraint | Threshold |\n|------------|-----------|\n| Max file size | 50MB (throw error) |\n| Parse time (<1MB) | < 100ms |\n| Recursion depth (generic) | 3 levels |\n\n# Acceptance Criteria\n- [ ] **Format v1:** Parse `{ initialPrompt, plan[], status }` structure\n- [ ] **Format v2:** Parse `{ goal, steps[], execution }` structure\n- [ ] **Generic Fallback:** Extract goal/steps using heuristic field search\n- [ ] **Size Guard:** Throw `SessionParseError` for files > 50MB\n- [ ] **Malformed JSON:** Throw `SessionParseError` with line number\n- [ ] **Partial Success:** Extract what's possible, fill missing with defaults\n- [ ] **Extensible:** Allow registering new format detectors at runtime\n",
  "code_patch": "",
  "success": false,
  "test_results": "{\"exit_code\": 2, \"stdout\": \"\\n> cc-mirror-ag-state-bridge@0.1.0 test\\n> jest --coverage --json --outputFile=test-results.json 2>&1 | tee test-output.log; exit ${PIPESTATUS[0]} --silent --json\\n\\nsh: 1: jest: not found\\n\", \"stderr\": \"sh: 1: Bad substitution\\n\", \"success\": false}"
}