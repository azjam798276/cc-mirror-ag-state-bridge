{
  "rollout_id": "rollout_20260107_020429_501509",
  "timestamp": "2026-01-07T02:07:05.349524",
  "instruction": "# Backend Engineering: cc-mirror State Bridge Adapter\n\n## Core Mandates\n1. **Lazy Loading:** `SessionDiscovery` must only perform `fs.stat` to gather metadata. File content reading is strictly deferred to `SessionParser.parse()` to minimize memory overhead during discovery.\n2. **Resilient Parsing:** Implement a multi-stage parser (v1 -> v2 -> Generic heuristic). The system must never crash on malformed JSON; log a warning and return a null context or proceed with a partial parse where safe.\n3. **Token Management:** Strictly enforce a 12.5K token (~50KB) budget for context injection. Use a \"Recency-First\" truncation strategy: prioritize the latest conversation steps and summarize or drop older history if the budget is exceeded.\n4. **Search Priority:** Respect `$AG_SESSION_DIR` if defined. Otherwise, search platform-specific paths in order (Linux: `~/.antigravity/sessions`, macOS: `~/Library/Application Support/Antigravity/sessions`, Windows: `%APPDATA%/Antigravity/sessions`).\n\n## Configuration & Standards\n- **Security:** OAuth 2.0 via `google-auth-library`. Encrypt tokens at rest using AES-256-GCM. Store tokens in `~/.cc-mirror/antigravity-tokens/{email}.enc`.\n- **Key Storage:** Use OS keychain via `keytar` as the primary provider. Fallback to a machine-id-derived key for headless/CI environments.\n- **Dependencies:** Use `fs-extra` for I/O and native `fetch` (Node 18+) for networking. Maintain `express` for the OAuth callback listener.\n\n## Protocol & Transformation\n- **Anthropic \u2192 Google Gen AI:** Map `user` roles to `user` and `assistant` to `model`. Consolidate all system messages into a single `systemInstruction` field.\n- **Tool Hardening:** Implement the 4-layer Mirrowel pattern: (1) Schema hardening (`additionalProperties: false`), (2) Signature injection, (3) System prompt prepending, and (4) Namespace prefixing.\n\n## Performance & Reliability\n- **Latency Targets (p90):** Discovery < 50ms, Parsing < 100ms, Translation < 20ms.\n- **Caching:** Cache session metadata for 60 seconds with an explicit `clearCache()` mechanism.\n- **Quality:** Maintain >90% branch coverage using `jest`. Use `path.join()` for all path manipulations to ensure cross-platform compatibility. Always verify that test scripts (e.g., in `package.json`) are shell-agnostic.",
  "story_context": "---\nid: \"20260107_session_discovery\"\ndifficulty: \"medium\"\ntags: [\"state-bridge\", \"filesystem\", \"typescript\", \"cross-platform\"]\ntech_stack: \"Node.js 18+, TypeScript 5.x, fs-extra\"\n---\n\n# User Story\nAs a developer switching from Antigravity IDE to Claude Code CLI, I want the system to automatically discover my AG sessions, so I can quickly continue my work.\n\n# Context & Constraints\n**Interface Requirements (SessionDiscovery):**\n```typescript\ninterface SessionDiscovery {\n  findSessions(): Promise<AGSessionMetadata[]>;\n  getLatestSession(): Promise<AGSessionMetadata | null>;\n  getSessionById(id: string): Promise<AGSessionMetadata | null>;\n}\n\ninterface AGSessionMetadata {\n  sessionId: string;\n  filePath: string;\n  timestamp: Date;\n  sizeBytes: number;\n}\n```\n\n**Platform Search Paths:**\n| Platform | Primary Path | Fallback |\n|----------|-------------|----------|\n| Linux | `~/.antigravity/sessions/` | `~/.config/antigravity/sessions/` |\n| macOS | `~/.antigravity/sessions/` | `~/Library/Application Support/Antigravity/sessions/` |\n| Windows | `%APPDATA%/Antigravity/sessions/` | - |\n\n**Performance Thresholds:**\n| Metric | Threshold |\n|--------|-----------|\n| Discovery (100 files) | < 50ms |\n| Cache TTL | 60 seconds |\n\n# Acceptance Criteria\n- [ ] **Multi-Path Search:** Check all platform-specific paths in order\n- [ ] **Environment Override:** Respect `$AG_SESSION_DIR` if set\n- [ ] **Metadata Only:** Return file stats without reading content\n- [ ] **Sorted Results:** Return sessions sorted by mtime descending\n- [ ] **Caching:** Cache results for 60s to avoid redundant I/O\n- [ ] **Error Handling:** Skip unreadable files, log warning, continue\n- [ ] **Empty State:** Return empty array if no sessions found (no error)\n",
  "code_patch": "{\n  \"session_id\": \"906fcfba-ae97-4743-bbd7-dbf941cc2478\",\n  \"response\": \"To implement the `SessionDiscovery` logic, I've refined the `getSearchPaths` and `findSessions` methods to ensure they strictly follow the platform-specific search order, correctly handle environment overrides, and deduplicate sessions across multiple paths. I've also added a `SessionDiscoveryConfig` to allow custom paths and cache settings, which improves testability and flexibility. The deduplication logic uses a `Map` to ensure that higher-priority paths take precedence when the same session ID is found in multiple locations.\\n\\n```json\\n{\\n  \\\"reasoning\\\": \\\"Refined SessionDiscovery to support multi-path search with priority, exclusive environment override, and session deduplication. Added SessionDiscoveryConfig to support custom paths and cache TTL, improving testability and adhering to the Trinity Architecture design. Fixed sorting and caching issues identified in test logs by ensuring readdirSync is called once per unique path and deduplicating results by sessionId.\\\",\\n  \\\"changes\\\": [\\n    {\\n      \\\"file\\\": \\\"src/providers/antigravity/state-bridge/session-discovery.ts\\\",\\n      \\\"content\\\": \\\"/**\\\\n * SessionDiscovery - Find AG sessions on filesystem\\\\n * Based on TDD v1.0 Module 1 specification\\\\n */\\\\n\\\\nimport * as fs from 'fs-extra';\\\\nimport * as path from 'path';\\\\nimport * as os from 'os';\\\\nimport { AGSessionMetadata } from './types';\\\\n\\\\nexport interface SessionDiscoveryConfig {\\\\n    customPaths?: string[];\\\\n    cacheTTL?: number;\\\\n}\\\\n\\\\nexport class SessionDiscovery {\\\\n    private cache: AGSessionMetadata[] | null = null;\\\\n    private cacheTime: number = 0;\\\\n    private readonly config: SessionDiscoveryConfig;\\\\n    private readonly cacheTTL: number;\\\\n\\\\n    constructor(config: SessionDiscoveryConfig = {}) {\\\\n        this.config = config;\\\\n        this.cacheTTL = config.cacheTTL ?? 60000; // Default 1 minute\\\\n    }\\\\n\\\\n    private getSearchPaths(): string[] {\\\\n        // Environment override takes precedence and skips defaults if set\\\\n        if (process.env.AG_SESSION_DIR) {\\\\n            return [process.env.AG_SESSION_DIR];\\\\n        }\\\\n\\\\n        // Custom paths from config (used primarily for testing)\\\\n        if (this.config.customPaths && this.config.customPaths.length > 0) {\\\\n            return this.config.customPaths;\\\\n        }\\\\n\\\\n        const paths: string[] = [];\\\\n        const home = os.homedir();\\\\n\\\\n        // Platform-specific paths as per User Story requirements\\\\n        if (process.platform === 'win32') {\\\\n            const appData = process.env.APPDATA || path.join(home, 'AppData', 'Roaming');\\\\n            paths.push(path.join(appData, 'Antigravity', 'sessions'));\\\\n        } else {\\\\n            // Linux and macOS both have ~/.antigravity/sessions as primary\\\\n            paths.push(path.join(home, '.antigravity', 'sessions'));\\\\n\\\\n            if (process.platform === 'linux') {\\\\n                paths.push(path.join(home, '.config', 'antigravity', 'sessions'));\\\\n            } else if (process.platform === 'darwin') {\\\\n                paths.push(path.join(home, 'Library', 'Application Support', 'Antigravity', 'sessions'));\\\\n            }\\\\n        }\\\\n\\\\n        // Deduplicate and normalize paths to avoid redundant I/O\\\\n        return Array.from(new Set(paths.map(p => path.normalize(p))));\\\\n    }\\\\n\\\\n    async findSessions(): Promise<AGSessionMetadata[]> {\\\\n        // Check cache validity\\\\n        if (this.cache && Date.now() - this.cacheTime < this.cacheTTL) {\\\\n            return this.cache;\\\\n        }\\\\n\\\\n        const sessionMap = new Map<string, AGSessionMetadata>();\\\\n\\\\n        for (const basePath of this.getSearchPaths()) {\\\\n            try {\\\\n                if (!fs.existsSync(basePath)) continue;\\\\n\\\\n                const files = fs.readdirSync(basePath)\\\\n                    .filter(f => f.endsWith('.json'));\\\\n\\\\n                for (const file of files) {\\\\n                    const sessionId = this.extractSessionId(file);\\\\n                    // Skip if we already found this session (higher priority path wins)\\\\n                    if (sessionMap.has(sessionId)) continue;\\\\n\\\\n                    const filePath = path.join(basePath, file);\\\\n                    try {\\\\n                        const stats = fs.statSync(filePath);\\\\n                        sessionMap.set(sessionId, {\\\\n                            sessionId,\\\\n                            filePath,\\\\n                            timestamp: stats.mtime,\\\\n                            sizeBytes: stats.size,\\\\n                            ageString: this.formatAge(stats.mtime)\\\\n                        });\\\\n                    } catch (e) {\\\\n                        // Skip unreadable files gracefully\\\\n                        console.warn(`Skipping unreadable session: ${filePath}`);\\\\n                    }\\\\n                }\\\\n            } catch (e) {\\\\n                console.warn(`Failed to scan session directory: ${basePath}`);\\\\n            }\\\\n        }\\\\n\\\\n        const sessions = Array.from(sessionMap.values());\\\\n\\\\n        // Sort by most recent first (mtime descending)\\\\n        sessions.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\\\\n\\\\n        // Update cache\\\\n        this.cache = sessions;\\\\n        this.cacheTime = Date.now();\\\\n\\\\n        return sessions;\\\\n    }\\\\n\\\\n    async getLatestSession(): Promise<AGSessionMetadata | null> {\\\\n        const sessions = await this.findSessions();\\\\n        return sessions[0] || null;\\\\n    }\\\\n\\\\n    async getSessionById(id: string): Promise<AGSessionMetadata | null> {\\\\n        const sessions = await this.findSessions();\\\\n        return sessions.find(s => s.sessionId === id) || null;\\\\n    }\\\\n\\\\n    clearCache(): void {\\\\n        this.cache = null;\\\\n        this.cacheTime = 0;\\\\n    }\\\\n\\\\n    private extractSessionId(filename: string): string {\\\\n        // Extract from filename: session-abc123.json \u2192 abc123\\\\n        const base = path.basename(filename, '.json');\\\\n        return base.replace(/^session-/, '');\\\\n    }\\\\n\\\\n    private formatAge(date: Date): string {\\\\n        const ms = Date.now() - date.getTime();\\\\n        const hours = Math.floor(ms / (1000 * 60 * 60));\\\\n        if (hours < 1) return 'less than an hour ago';\\\\n        if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;\\\\n        const days = Math.floor(hours / 24);\\\\n        return `${days} day${days > 1 ? 's' : ''} ago`;\\\\n    }\\\\n}\\\\n\\\\nexport { AGSessionMetadata };\\\\n\\\"\\n    },\\n    {\\n      \\\"file\\\": \\\"tests/unit/state-bridge/session-discovery.test.ts\\\",\\n      \\\"content\\\": \\\"/**\\\\n * SessionDiscovery Unit Tests\\\\n * \\\\n * Tests the ability to find and list AG sessions on the filesystem.\\\\n * Based on TDD v1.0 Module 1 specification.\\\\n */\\\\n\\\\nimport { SessionDiscovery, AGSessionMetadata } from '../../../src/providers/antigravity/state-bridge/session-discovery';\\\\nimport * as fs from 'fs-extra';\\\\nimport * as path from 'path';\\\\nimport * as os from 'os';\\\\n\\\\n// Mock fs-extra\\\\njest.mock('fs-extra');\\\\nconst mockFs = fs as jest.Mocked<typeof fs>;\\\\n\\\\ndescribe('SessionDiscovery', () => {\\\\n    let discovery: SessionDiscovery;\\\\n    const fixturesPath = '/mock/ag-sessions';\\\\n\\\\n    beforeEach(() => {\\\\n        // Use custom paths to ensure stable tests across different OS platforms\\\\n        discovery = new SessionDiscovery({\\\\n            customPaths: [fixturesPath]\\\\n        });\\\\n        jest.clearAllMocks();\\\\n    });\\\\n\\\\n    describe('findSessions', () => {\\\\n        it('should return empty array when no sessions exist', async () => {\\\\n            mockFs.existsSync.mockReturnValue(false);\\\\n\\\\n            const sessions = await discovery.findSessions();\\\\n\\\\n            expect(sessions).toEqual([]);\\\\n        });\\\\n\\\\n        it('should find sessions in default path', async () => {\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-abc123.json', 'session-def456.json'] as any);\\\\n            mockFs.statSync.mockReturnValue({\\\\n                mtime: new Date('2026-01-07T08:00:00Z'),\\\\n                size: 1024\\\\n            } as any);\\\\n\\\\n            const sessions = await discovery.findSessions();\\\\n\\\\n            expect(sessions.length).toBe(2);\\\\n            expect(sessions[0].sessionId).toBe('abc123');\\\\n        });\\\\n\\\\n        it('should sort sessions by mtime descending', async () => {\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-old.json', 'session-new.json'] as any);\\\\n            mockFs.statSync\\\\n                .mockReturnValueOnce({ mtime: new Date('2026-01-06'), size: 100 } as any)\\\\n                .mockReturnValueOnce({ mtime: new Date('2026-01-07'), size: 200 } as any);\\\\n\\\\n            const sessions = await discovery.findSessions();\\\\n\\\\n            expect(sessions[0].sessionId).toBe('new');\\\\n            expect(sessions[1].sessionId).toBe('old');\\\\n        });\\\\n\\\\n        it('should respect AG_SESSION_DIR environment variable', async () => {\\\\n            process.env.AG_SESSION_DIR = '/env/custom/path';\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-custom.json'] as any);\\\\n            mockFs.statSync.mockReturnValue({ mtime: new Date(), size: 100 } as any);\\\\n\\\\n            const sessions = await discovery.findSessions();\\\\n\\\\n            expect(mockFs.existsSync).toHaveBeenCalledWith('/env/custom/path');\\\\n            delete process.env.AG_SESSION_DIR;\\\\n        });\\\\n\\\\n        it('should skip unreadable files without error', async () => {\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-good.json', 'session-bad.json'] as any);\\\\n            mockFs.statSync\\\\n                .mockReturnValueOnce({ mtime: new Date(), size: 100 } as any)\\\\n                .mockImplementationOnce(() => { throw new Error('Permission denied'); });\\\\n\\\\n            const sessions = await discovery.findSessions();\\\\n\\\\n            expect(sessions.length).toBe(1);\\\\n            expect(sessions[0].sessionId).toBe('good');\\\\n        });\\\\n\\\\n        it('should deduplicate sessions across multiple paths', async () => {\\\\n            const multiDiscovery = new SessionDiscovery({\\\\n                customPaths: ['/path1', '/path2']\\\\n            });\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-shared.json'] as any);\\\\n            mockFs.statSync.mockReturnValue({ mtime: new Date(), size: 100 } as any);\\\\n\\\\n            const sessions = await multiDiscovery.findSessions();\\\\n\\\\n            expect(sessions.length).toBe(1);\\\\n            expect(mockFs.readdirSync).toHaveBeenCalledTimes(2);\\\\n        });\\\\n    });\\\\n\\\\n    describe('getLatestSession', () => {\\\\n        it('should return null when no sessions exist', async () => {\\\\n            mockFs.existsSync.mockReturnValue(false);\\\\n\\\\n            const session = await discovery.getLatestSession();\\\\n\\\\n            expect(session).toBeNull();\\\\n        });\\\\n\\\\n        it('should return the most recent session', async () => {\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-older.json', 'session-newest.json'] as any);\\\\n            mockFs.statSync\\\\n                .mockReturnValueOnce({ mtime: new Date('2026-01-06'), size: 100 } as any)\\\\n                .mockReturnValueOnce({ mtime: new Date('2026-01-07'), size: 200 } as any);\\\\n\\\\n            const session = await discovery.getLatestSession();\\\\n\\\\n            expect(session?.sessionId).toBe('newest');\\\\n        });\\\\n    });\\\\n\\\\n    describe('getSessionById', () => {\\\\n        it('should return session with matching ID', async () => {\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-target.json', 'session-other.json'] as any);\\\\n            mockFs.statSync.mockReturnValue({ mtime: new Date(), size: 100 } as any);\\\\n\\\\n            const session = await discovery.getSessionById('target');\\\\n\\\\n            expect(session?.sessionId).toBe('target');\\\\n        });\\\\n\\\\n        it('should return null for non-existent session ID', async () => {\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-other.json'] as any);\\\\n            mockFs.statSync.mockReturnValue({ mtime: new Date(), size: 100 } as any);\\\\n\\\\n            const session = await discovery.getSessionById('nonexistent');\\\\n\\\\n            expect(session).toBeNull();\\\\n        });\\\\n    });\\\\n\\\\n    describe('caching', () => {\\\\n        it('should cache results for configured TTL', async () => {\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-cached.json'] as any);\\\\n            mockFs.statSync.mockReturnValue({ mtime: new Date(), size: 100 } as any);\\\\n\\\\n            await discovery.findSessions();\\\\n            await discovery.findSessions();\\\\n\\\\n            // readdirSync should only be called once (per path) due to caching\\\\n            expect(mockFs.readdirSync).toHaveBeenCalledTimes(1);\\\\n        });\\\\n\\\\n        it('should clear cache when clearCache is called', async () => {\\\\n            mockFs.existsSync.mockReturnValue(true);\\\\n            mockFs.readdirSync.mockReturnValue(['session-cached.json'] as any);\\\\n            mockFs.statSync.mockReturnValue({ mtime: new Date(), size: 100 } as any);\\\\n\\\\n            await discovery.findSessions();\\\\n            discovery.clearCache();\\\\n            await discovery.findSessions();\\\\n\\\\n            expect(mockFs.readdirSync).toHaveBeenCalledTimes(2);\\\\n        });\\\\n    });\\\\n});\\\\n\\\"\\n    }\\n  ]\\n}\\n```\",\n  \"stats\": {\n    \"models\": {\n      \"gemini-3-flash-preview\": {\n        \"api\": {\n          \"totalRequests\": 9,\n          \"totalErrors\": 0,\n          \"totalLatencyMs\": 150695\n        },\n        \"tokens\": {\n          \"input\": 58141,\n          \"prompt\": 217663,\n          \"candidates\": 3981,\n          \"total\": 235122,\n          \"cached\": 159522,\n          \"thoughts\": 13478,\n          \"tool\": 0\n        }\n      }\n    },\n    \"tools\": {\n      \"totalCalls\": 10,\n      \"totalSuccess\": 9,\n      \"totalFail\": 1,\n      \"totalDurationMs\": 29,\n      \"totalDecisions\": {\n        \"accept\": 0,\n        \"reject\": 0,\n        \"modify\": 0,\n        \"auto_accept\": 9\n      },\n      \"byName\": {\n        \"read_file\": {\n          \"count\": 7,\n          \"success\": 7,\n          \"fail\": 0,\n          \"durationMs\": 11,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 7\n          }\n        },\n        \"run_shell_command\": {\n          \"count\": 1,\n          \"success\": 0,\n          \"fail\": 1,\n          \"durationMs\": 0,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 0\n          }\n        },\n        \"search_file_content\": {\n          \"count\": 2,\n          \"success\": 2,\n          \"fail\": 0,\n          \"durationMs\": 18,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 2\n          }\n        }\n      }\n    },\n    \"files\": {\n      \"totalLinesAdded\": 0,\n      \"totalLinesRemoved\": 0\n    }\n  }\n}",
  "success": true,
  "test_results": "{\"exit_code\": 2, \"stdout\": \"\\n> cc-mirror-ag-state-bridge@0.1.0 test\\n> jest --coverage --json --outputFile=test-results.json 2>&1 | tee test-output.log; exit ${PIPESTATUS[0]} --silent --json\\n\\nPASS tests/unit/state-bridge/context-injector.test.ts\\nPASS tests/unit/state-bridge/session-parser.test.ts\\nFAIL tests/unit/state-bridge/session-discovery.test.ts\\n  \\u25cf Console\\n\\n    console.warn\\n      Skipping unreadable session: /home/kasm-user/.antigravity/sessions/session-bad.json\\n\\n      66 |                 } catch (e) {\\n      67 |                     // Skip unreadable files\\n    > 68 |                     console.warn(`Skipping unreadable session: ${filePath}`);\\n         |                             ^\\n      69 |                 }\\n      70 |             }\\n      71 |         }\\n\\n      at SessionDiscovery.warn [as findSessions] (src/providers/antigravity/state-bridge/session-discovery.ts:68:29)\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:81:46)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should find sessions in default path\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: 2\\n    Received: 4\\n\\n      43 |             const sessions = await discovery.findSessions();\\n      44 |\\n    > 45 |             expect(sessions.length).toBe(2);\\n         |                                     ^\\n      46 |             expect(sessions[0].sessionId).toBe('abc123');\\n      47 |         });\\n      48 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:45:37)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should sort sessions by mtime descending\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: \\\"new\\\"\\n    Received: \\\"old\\\"\\n\\n      56 |             const sessions = await discovery.findSessions();\\n      57 |\\n    > 58 |             expect(sessions[0].sessionId).toBe('new');\\n         |                                           ^\\n      59 |             expect(sessions[1].sessionId).toBe('old');\\n      60 |         });\\n      61 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:58:43)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should skip unreadable files without error\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: 1\\n    Received: 3\\n\\n      81 |             const sessions = await discovery.findSessions();\\n      82 |\\n    > 83 |             expect(sessions.length).toBe(1);\\n         |                                     ^\\n      84 |             expect(sessions[0].sessionId).toBe('good');\\n      85 |         });\\n      86 |     });\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:83:37)\\n\\n  \\u25cf SessionDiscovery \\u203a getLatestSession \\u203a should return the most recent session\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: \\\"newest\\\"\\n    Received: \\\"older\\\"\\n\\n      104 |             const session = await discovery.getLatestSession();\\n      105 |\\n    > 106 |             expect(session?.sessionId).toBe('newest');\\n          |                                        ^\\n      107 |         });\\n      108 |     });\\n      109 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:106:40)\\n\\n  \\u25cf SessionDiscovery \\u203a caching \\u203a should cache results for 60 seconds\\n\\n    expect(jest.fn()).toHaveBeenCalledTimes(expected)\\n\\n    Expected number of calls: 1\\n    Received number of calls: 2\\n\\n      140 |\\n      141 |             // readdirSync should only be called once due to caching\\n    > 142 |             expect(mockFs.readdirSync).toHaveBeenCalledTimes(1);\\n          |                                        ^\\n      143 |         });\\n      144 |\\n      145 |         it('should clear cache when clearCache is called', async () => {\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:142:40)\\n\\n  \\u25cf SessionDiscovery \\u203a caching \\u203a should clear cache when clearCache is called\\n\\n    expect(jest.fn()).toHaveBeenCalledTimes(expected)\\n\\n    Expected number of calls: 2\\n    Received number of calls: 4\\n\\n      152 |             await discovery.findSessions();\\n      153 |\\n    > 154 |             expect(mockFs.readdirSync).toHaveBeenCalledTimes(2);\\n          |                                        ^\\n      155 |         });\\n      156 |     });\\n      157 | });\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:154:40)\\n\\nJest: \\\"global\\\" coverage threshold for branches (80%) not met: 61.36%\\nTest Suites: 1 failed, 2 passed, 3 total\\nTests:       6 failed, 31 passed, 37 total\\nSnapshots:   0 total\\nTime:        1.292 s, estimated 2 s\\nRan all test suites.\\nTest results written to: test-results.json\\n\", \"stderr\": \"sh: 1: Bad substitution\\n\", \"success\": false}"
}