{
  "rollout_id": "rollout_20260107_025222_126637",
  "timestamp": "2026-01-07T02:54:55.752069",
  "instruction": "# Security Engineering: cc-mirror State Bridge Adapter\n\n## Core Mandates\n1. **Keychain-First & Fail-Secure:** Always prioritize the OS keychain (`keytar`) for storing encryption keys. Fall back to Machine-ID + PBKDF2 (100K iterations, SHA-256) ONLY on headless systems. NEVER store keys in plaintext or environment variables.\n2. **Authenticated Encryption:** All OAuth tokens MUST be encrypted at rest using AES-256-GCM. Every encrypted record must include a unique 12-byte random IV and the GCM AuthTag.\n3. **Defensive Path Handling:** Prevent directory traversal by canonicalizing all file paths (using `path.resolve`) and verifying they reside within authorized session directories before access.\n4. **Resource Constraints:** Enforce a 50MB maximum file size for session files and a hard recursion depth limit of 5 for generic JSON parsing to prevent Denial of Service (DoS) attacks.\n\n## Security Standards\n- **Encryption:** AES-256-GCM (via Node.js `crypto` module).\n- **Key Derivation:** For headless fallback, use PBKDF2 with 100,000 iterations, a 32-byte output key, and the static salt `cc-mirror-antigravity-v1`.\n- **Tool Hardening:** Implement the Mirrowel 4-layer prevention: Schema hardening (`additionalProperties: false`), signature injection, system prompt prepending, and namespace prefixing.\n- **Thinking Sanitization:** Automatically detect and strip internal model thinking blocks (`<thought>` or similar) before injecting context to prevent prompt leakage.\n\n## Code Review Checklist\n- [ ] **No Secrets in Logs:** Ensure tokens, keys, and authorization codes are NEVER logged or included in telemetry.\n- [ ] **Path Validation:** Verify that all file operations use canonicalized paths validated against a whitelist.\n- [ ] **Pre-read Checks:** Confirm `fs.stat()` is called to check file size BEFORE attempting to read content into memory.\n- [ ] **Safe Parsing:** Verify that the generic JSON parser implements an explicit depth counter with a limit of 5.\n- [ ] **OAuth Lockdown:** Redirect URI must be strictly pinned to `http://localhost:51121/callback`.\n- [ ] **Telemetry Sanitization:** Confirm that all telemetry events are stripped of PII and sensitive session metadata.\n\n## Headless Documentation Required\n```markdown\n\u26a0\ufe0f Security Warning for Headless Servers:\n- Encryption keys are derived from the machine ID; tokens may be portable if the filesystem is compromised.\n- Use service accounts with minimal permissions rather than user-level OAuth tokens where possible.\n- Ensure the execution environment (e.g., Docker, VPS) is secured against unauthorized filesystem access.\n```",
  "story_context": "---\nid: \"20260107_secure_storage\"\ndifficulty: \"hard\"\ntags: [\"oauth\", \"security\", \"encryption\", \"keychain\", \"typescript\"]\ntech_stack: \"Node.js 18+, TypeScript 5.x, keytar, crypto\"\n---\n\n# User Story\nAs a developer, I want my OAuth tokens stored securely, so they can't be stolen from my filesystem.\n\n# Context & Constraints\n**Interface Requirements (SecureStorage):**\n```typescript\ninterface SecureStorage {\n  saveToken(email: string, credentials: OAuthCredentials): Promise<void>;\n  loadToken(email: string): Promise<OAuthCredentials | null>;\n  deleteToken(email: string): Promise<void>;\n  listAccounts(): Promise<string[]>;\n}\n```\n\n**Encryption Architecture:**\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 OS Keychain (keytar)                    \u2502\n\u2502 - Service: cc-mirror-antigravity        \u2502\n\u2502 - Account: encryption-key               \u2502\n\u2502 - Value: 256-bit AES key                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Token Files (~/.cc-mirror/tokens/)      \u2502\n\u2502 - {email}.enc                           \u2502\n\u2502 - Format: { iv, authTag, data }         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Security Requirements:**\n| Requirement | Implementation |\n|-------------|----------------|\n| Encryption | AES-256-GCM |\n| Key storage | OS keychain (keytar) |\n| Fallback | Machine-ID + PBKDF2 |\n| IV | Random 16 bytes per token |\n\n# Acceptance Criteria\n- [ ] **Keychain Integration:** Store encryption key in OS keychain\n- [ ] **Encryption:** Encrypt tokens with AES-256-GCM before disk write\n- [ ] **Decryption:** Decrypt tokens on load; fail gracefully if corrupted\n- [ ] **Headless Fallback:** Use machine-id + PBKDF2 if no keychain\n- [ ] **Multi-Account:** Support storing tokens for multiple emails\n- [ ] **Atomic Writes:** Use temp-file-and-rename to prevent corruption\n- [ ] **No Plaintext:** Never write unencrypted tokens to disk\n",
  "code_patch": "{\n  \"session_id\": \"a87064d2-9021-4543-b191-56ba126f4f5b\",\n  \"response\": \"I will now output the reasoning and the code changes in the requested JSON format.\\n\\n## Reasoning\\nThe `SecureStorage` implementation follows the requirements of the \\\"Secure Token Storage\\\" user story and the architecture defined in the ADD/TDD. \\n\\n1.  **Interface Adherence**: I've implemented the `SecureStorage` interface as defined in the story, including `saveToken`, `loadToken`, `deleteToken`, and `listAccounts`.\\n2.  **Encryption Architecture**: \\n    *   **Algorithm**: Uses `AES-256-GCM` for authenticated encryption, ensuring both confidentiality and integrity of the tokens.\\n    *   **Key Management**: The encryption key is a random 256-bit buffer stored in the OS Keychain via `keytar`. This ensures that even if an attacker steals the encrypted files from the disk, they cannot decrypt them without access to the OS keychain.\\n    *   **Headless Fallback**: For environments without a keychain (e.g., CI/CD, headless servers), the system falls back to a deterministic key derived from a machine-specific identifier (`/etc/machine-id` or hostname) and a salt using PBKDF2 with 100,000 iterations.\\n3.  **Storage Logic**:\\n    *   **Directory**: Tokens are stored in `~/.cc-mirror/tokens/` (configurable).\\n    *   **Format**: Tokens are stored as JSON files (`{email}.enc`) containing the hex-encoded IV, authentication tag, and encrypted data.\\n    *   **Atomicity**: Uses a temporary file and rename strategy to ensure that token writes are atomic, preventing file corruption in case of power loss or crashes during the write operation.\\n4.  **Security Best Practices**:\\n    *   Random 16-byte IV for every encryption operation.\\n    *   Encryption-then-MAC (via GCM's auth tag) to prevent padding oracle attacks and tampering.\\n    *   Never writes unencrypted tokens to the filesystem.\\n\\n## Code Changes\\n```json\\n{\\n  \\\"files\\\": [\\n    {\\n      \\\"path\\\": \\\"src/providers/antigravity/oauth/types.ts\\\",\\n      \\\"content\\\": \\\"/**\\\\n * OAuth Credentials and Storage Types\\\\n */\\\\n\\\\nexport interface OAuthCredentials {\\\\n  access_token?: string | null;\\\\n  refresh_token?: string | null;\\\\n  scope?: string | null;\\\\n  token_type?: string | null;\\\\n  expiry_date?: number | null;\\\\n}\\\\n\\\\nexport interface SecureStorage {\\\\n  /**\\\\n   * Encrypts and saves tokens for a specific account.\\\\n   */\\\\n  saveToken(email: string, credentials: OAuthCredentials): Promise<void>;\\\\n\\\\n  /**\\\\n   * Loads and decrypts tokens for a specific account.\\\\n   */\\\\n  loadToken(email: string): Promise<OAuthCredentials | null>;\\\\n\\\\n  /**\\\\n   * Deletes tokens for a specific account.\\\\n   */\\\\n  deleteToken(email: string): Promise<void>;\\\\n\\\\n  /**\\\\n   * Lists all emails with stored tokens.\\\\n   */\\\\n  listAccounts(): Promise<string[]>;\\\\n}\\\\n\\\"\\n    },\\n    {\\n      \\\"path\\\": \\\"src/providers/antigravity/oauth/secure-storage.ts\\\",\\n      \\\"content\\\": \\\"import * as crypto from 'crypto';\\\\nimport * as fs from 'fs-extra';\\\\nimport * as path from 'path';\\\\nimport * as os from 'os';\\\\nimport * as keytar from 'keytar';\\\\nimport { OAuthCredentials, SecureStorage } from './types';\\\\n\\\\n/**\\\\n * Implementation of SecureStorage using AES-256-GCM and OS Keychain.\\\\n * Provides atomic writes and headless fallback.\\\\n */\\\\nexport class FileSecureStorage implements SecureStorage {\\\\n  private readonly storageDir: string;\\\\n  private readonly SERVICE_NAME = 'cc-mirror-antigravity';\\\\n  private readonly ACCOUNT_NAME = 'encryption-key';\\\\n  private cachedKey: Buffer | null = null;\\\\n\\\\n  constructor(storageDir?: string) {\\\\n    this.storageDir = storageDir || path.join(os.homedir(), '.cc-mirror', 'tokens');\\\\n  }\\\\n\\\\n  async saveToken(email: string, credentials: OAuthCredentials): Promise<void> {\\\\n    await fs.ensureDir(this.storageDir);\\\\n    const key = await this.getEncryptionKey();\\\\n    \\\\n    // Requirement: IV | Random 16 bytes per token\\\\n    const iv = crypto.randomBytes(16);\\\\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\\\\n\\\\n    const data = JSON.stringify(credentials);\\\\n    let encrypted = cipher.update(data, 'utf8', 'hex');\\\\n    encrypted += cipher.final('hex');\\\\n    const authTag = cipher.getAuthTag();\\\\n\\\\n    // Requirement: Format: { iv, authTag, data }\\\\n    const payload = {\\\\n      iv: iv.toString('hex'),\\\\n      authTag: authTag.toString('hex'),\\\\n      data: encrypted,\\\\n      version: '1'\\\\n    };\\\\n\\\\n    const filePath = path.join(this.storageDir, `${email}.enc`);\\\\n    \\\\n    // Requirement: Atomic Writes: Use temp-file-and-rename\\\\n    const tempPath = `${filePath}.${crypto.randomBytes(4).toString('hex')}.tmp`;\\\\n    \\\\n    try {\\\\n      await fs.writeJSON(tempPath, payload);\\\\n      await fs.rename(tempPath, filePath);\\\\n    } catch (error) {\\\\n      if (await fs.pathExists(tempPath)) {\\\\n        await fs.remove(tempPath);\\\\n      }\\\\n      throw error;\\\\n    }\\\\n  }\\\\n\\\\n  async loadToken(email: string): Promise<OAuthCredentials | null> {\\\\n    const filePath = path.join(this.storageDir, `${email}.enc`);\\\\n    if (!(await fs.pathExists(filePath))) {\\\\n      return null;\\\\n    }\\\\n\\\\n    try {\\\\n      const payload = await fs.readJSON(filePath);\\\\n      const { iv, authTag, data } = payload;\\\\n      \\\\n      const key = await this.getEncryptionKey();\\\\n      const decipher = crypto.createDecipheriv(\\\\n        'aes-256-gcm', \\\\n        key, \\\\n        Buffer.from(iv, 'hex')\\\\n      );\\\\n      decipher.setAuthTag(Buffer.from(authTag, 'hex'));\\\\n\\\\n      let decrypted = decipher.update(data, 'hex', 'utf8');\\\\n      decrypted += decipher.final('utf8');\\\\n      \\\\n      return JSON.parse(decrypted);\\\\n    } catch (error) {\\\\n      // Graceful failure if corrupted\\\\n      return null;\\\\n    }\\\\n  }\\\\n\\\\n  async deleteToken(email: string): Promise<void> {\\\\n    const filePath = path.join(this.storageDir, `${email}.enc`);\\\\n    if (await fs.pathExists(filePath)) {\\\\n      await fs.remove(filePath);\\\\n    }\\\\n  }\\\\n\\\\n  async listAccounts(): Promise<string[]> {\\\\n    if (!(await fs.pathExists(this.storageDir))) {\\\\n      return [];\\\\n    }\\\\n    const files = await fs.readdir(this.storageDir);\\\\n    return files\\\\n      .filter(f => f.endsWith('.enc'))\\\\n      .map(f => f.slice(0, -4));\\\\n  }\\\\n\\\\n  private async getEncryptionKey(): Promise<Buffer> {\\\\n    if (this.cachedKey) return this.cachedKey;\\\\n\\\\n    let keyHex: string | null = null;\\\\n    try {\\\\n      // Requirement: Key storage | OS keychain (keytar)\\\\n      keyHex = await keytar.getPassword(this.SERVICE_NAME, this.ACCOUNT_NAME);\\\\n    } catch (e) {\\\\n      // Keychain might be unavailable (e.g. Linux without dbus/libsecret)\\\\n    }\\\\n\\\\n    if (!keyHex) {\\\\n      try {\\\\n        const newKey = crypto.randomBytes(32).toString('hex');\\\\n        await keytar.setPassword(this.SERVICE_NAME, this.ACCOUNT_NAME, newKey);\\\\n        keyHex = newKey;\\\\n      } catch (e) {\\\\n        // Requirement: Fallback | Machine-ID + PBKDF2\\\\n        return this.getFallbackKey();\\\\n      }\\\\n    }\\\\n\\\\n    this.cachedKey = Buffer.from(keyHex!, 'hex');\\\\n    return this.cachedKey;\\\\n  }\\\\n\\\\n  private async getFallbackKey(): Promise<Buffer> {\\\\n    let machineId = os.hostname();\\\\n    \\\\n    // Heuristic for stable machine-id on Linux\\\\n    if (process.platform === 'linux') {\\\\n      try {\\\\n        if (await fs.pathExists('/etc/machine-id')) {\\\\n          machineId = (await fs.readFile('/etc/machine-id', 'utf8')).trim();\\\\n        } else if (await fs.pathExists('/var/lib/dbus/machine-id')) {\\\\n          machineId = (await fs.readFile('/var/lib/dbus/machine-id', 'utf8')).trim();\\\\n        }\\\\n      } catch (e) {\\\\n        // Fallback to hostname\\\\n      }\\\\n    }\\\\n\\\\n    const salt = 'cc-mirror-antigravity-v1-salt';\\\\n    return new Promise((resolve, reject) => {\\\\n      // Requirement: PBKDF2 for derivation\\\\n      crypto.pbkdf2(machineId, salt, 100000, 32, 'sha256', (err, derivedKey) => {\\\\n        if (err) reject(err);\\\\n        else resolve(derivedKey);\\\\n      });\\\\n    });\\\\n  }\\\\n}\\\\n\\\"\\n    },\\n    {\\n      \\\"path\\\": \\\"tests/unit/providers/antigravity/oauth/secure-storage.test.ts\\\",\\n      \\\"content\\\": \\\"import * as fs from 'fs-extra';\\\\nimport * as path from 'path';\\\\nimport * as os from 'os';\\\\nimport { FileSecureStorage } from '../../../../../src/providers/antigravity/oauth/secure-storage';\\\\n\\\\n// Mock keytar to avoid requiring actual keychain in tests\\\\njest.mock('keytar', () => ({\\\\n  getPassword: jest.fn(),\\\\n  setPassword: jest.fn(),\\\\n}));\\\\n\\\\ndescribe('FileSecureStorage', () => {\\\\n  const testDir = path.join(os.tmpdir(), 'cc-mirror-test-tokens');\\\\n  let storage: FileSecureStorage;\\\\n\\\\n  beforeEach(async () => {\\\\n    await fs.remove(testDir);\\\\n    storage = new FileSecureStorage(testDir);\\\\n    jest.clearAllMocks();\\\\n  });\\\\n\\\\n  afterAll(async () => {\\\\n    await fs.remove(testDir);\\\\n  });\\\\n\\\\n  it('should save and load tokens correctly', async () => {\\\\n    const email = 'test@example.com';\\\\n    const credentials = {\\\\n      access_token: 'abc-123',\\\\n      refresh_token: 'def-456',\\\\n      expiry_date: 123456789\\\\n    };\\\\n\\\\n    await storage.saveToken(email, credentials);\\\\n    const loaded = await storage.loadToken(email);\\\\n\\\\n    expect(loaded).toEqual(credentials);\\\\n    expect(await fs.pathExists(path.join(testDir, `${email}.enc`))).toBe(true);\\\\n  });\\\\n\\\\n  it('should support multiple accounts', async () => {\\\\n    await storage.saveToken('a@example.com', { access_token: 'a' });\\\\n    await storage.saveToken('b@example.com', { access_token: 'b' });\\\\n\\\\n    const accounts = await storage.listAccounts();\\\\n    expect(accounts).toContain('a@example.com');\\\\n    expect(accounts).toContain('b@example.com');\\\\n    expect(accounts.length).toBe(2);\\\\n  });\\\\n\\\\n  it('should return null for non-existent account', async () => {\\\\n    const loaded = await storage.loadToken('missing@example.com');\\\\n    expect(loaded).toBeNull();\\\\n  });\\\\n\\\\n  it('should delete tokens', async () => {\\\\n    const email = 'del@example.com';\\\\n    await storage.saveToken(email, { access_token: 'val' });\\\\n    await storage.deleteToken(email);\\\\n\\\\n    const loaded = await storage.loadToken(email);\\\\n    expect(loaded).toBeNull();\\\\n  });\\\\n\\\\n  it('should handle decryption failures gracefully', async () => {\\\\n    const email = 'corrupt@example.com';\\\\n    await storage.saveToken(email, { access_token: 'val' });\\\\n\\\\n    // Corrupt the file\\\\n    const filePath = path.join(testDir, `${email}.enc`);\\\\n    await fs.writeFile(filePath, 'invalid-json-or-wrong-format');\\\\n\\\\n    const loaded = await storage.loadToken(email);\\\\n    expect(loaded).toBeNull();\\\\n  });\\\\n});\\\\n\\\"\\n    }\\n  ]\\n}\\n```\",\n  \"stats\": {\n    \"models\": {\n      \"gemini-3-flash-preview\": {\n        \"api\": {\n          \"totalRequests\": 29,\n          \"totalErrors\": 0,\n          \"totalLatencyMs\": 149039\n        },\n        \"tokens\": {\n          \"input\": 94756,\n          \"prompt\": 709725,\n          \"candidates\": 4271,\n          \"total\": 725454,\n          \"cached\": 614969,\n          \"thoughts\": 11458,\n          \"tool\": 0\n        }\n      }\n    },\n    \"tools\": {\n      \"totalCalls\": 28,\n      \"totalSuccess\": 22,\n      \"totalFail\": 6,\n      \"totalDurationMs\": 83,\n      \"totalDecisions\": {\n        \"accept\": 0,\n        \"reject\": 0,\n        \"modify\": 0,\n        \"auto_accept\": 26\n      },\n      \"byName\": {\n        \"list_directory\": {\n          \"count\": 10,\n          \"success\": 7,\n          \"fail\": 3,\n          \"durationMs\": 36,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 10\n          }\n        },\n        \"read_file\": {\n          \"count\": 13,\n          \"success\": 12,\n          \"fail\": 1,\n          \"durationMs\": 19,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 13\n          }\n        },\n        \"search_file_content\": {\n          \"count\": 2,\n          \"success\": 2,\n          \"fail\": 0,\n          \"durationMs\": 21,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 2\n          }\n        },\n        \"glob\": {\n          \"count\": 1,\n          \"success\": 1,\n          \"fail\": 0,\n          \"durationMs\": 7,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 1\n          }\n        },\n        \"run_shell_command\": {\n          \"count\": 1,\n          \"success\": 0,\n          \"fail\": 1,\n          \"durationMs\": 0,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 0\n          }\n        },\n        \"write_file\": {\n          \"count\": 1,\n          \"success\": 0,\n          \"fail\": 1,\n          \"durationMs\": 0,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 0\n          }\n        }\n      }\n    },\n    \"files\": {\n      \"totalLinesAdded\": 0,\n      \"totalLinesRemoved\": 0\n    }\n  }\n}",
  "success": true,
  "test_results": "{\"exit_code\": 2, \"stdout\": \"\\n> cc-mirror-ag-state-bridge@0.1.0 test\\n> jest --coverage --json --outputFile=test-results.json 2>&1 | tee test-output.log; exit ${PIPESTATUS[0]} --silent --json\\n\\nFAIL tests/unit/state-bridge/session-discovery.test.ts\\n  \\u25cf Console\\n\\n    console.warn\\n      Skipping unreadable session: /home/kasm-user/.antigravity/sessions/session-bad.json\\n\\n      66 |                 } catch (e) {\\n      67 |                     // Skip unreadable files\\n    > 68 |                     console.warn(`Skipping unreadable session: ${filePath}`);\\n         |                             ^\\n      69 |                 }\\n      70 |             }\\n      71 |         }\\n\\n      at SessionDiscovery.warn [as findSessions] (src/providers/antigravity/state-bridge/session-discovery.ts:68:29)\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:81:46)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should find sessions in default path\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: 2\\n    Received: 4\\n\\n      43 |             const sessions = await discovery.findSessions();\\n      44 |\\n    > 45 |             expect(sessions.length).toBe(2);\\n         |                                     ^\\n      46 |             expect(sessions[0].sessionId).toBe('abc123');\\n      47 |         });\\n      48 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:45:37)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should sort sessions by mtime descending\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: \\\"new\\\"\\n    Received: \\\"old\\\"\\n\\n      56 |             const sessions = await discovery.findSessions();\\n      57 |\\n    > 58 |             expect(sessions[0].sessionId).toBe('new');\\n         |                                           ^\\n      59 |             expect(sessions[1].sessionId).toBe('old');\\n      60 |         });\\n      61 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:58:43)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should skip unreadable files without error\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: 1\\n    Received: 3\\n\\n      81 |             const sessions = await discovery.findSessions();\\n      82 |\\n    > 83 |             expect(sessions.length).toBe(1);\\n         |                                     ^\\n      84 |             expect(sessions[0].sessionId).toBe('good');\\n      85 |         });\\n      86 |     });\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:83:37)\\n\\n  \\u25cf SessionDiscovery \\u203a getLatestSession \\u203a should return the most recent session\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: \\\"newest\\\"\\n    Received: \\\"older\\\"\\n\\n      104 |             const session = await discovery.getLatestSession();\\n      105 |\\n    > 106 |             expect(session?.sessionId).toBe('newest');\\n          |                                        ^\\n      107 |         });\\n      108 |     });\\n      109 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:106:40)\\n\\n  \\u25cf SessionDiscovery \\u203a caching \\u203a should cache results for 60 seconds\\n\\n    expect(jest.fn()).toHaveBeenCalledTimes(expected)\\n\\n    Expected number of calls: 1\\n    Received number of calls: 2\\n\\n      140 |\\n      141 |             // readdirSync should only be called once due to caching\\n    > 142 |             expect(mockFs.readdirSync).toHaveBeenCalledTimes(1);\\n          |                                        ^\\n      143 |         });\\n      144 |\\n      145 |         it('should clear cache when clearCache is called', async () => {\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:142:40)\\n\\n  \\u25cf SessionDiscovery \\u203a caching \\u203a should clear cache when clearCache is called\\n\\n    expect(jest.fn()).toHaveBeenCalledTimes(expected)\\n\\n    Expected number of calls: 2\\n    Received number of calls: 4\\n\\n      152 |             await discovery.findSessions();\\n      153 |\\n    > 154 |             expect(mockFs.readdirSync).toHaveBeenCalledTimes(2);\\n          |                                        ^\\n      155 |         });\\n      156 |     });\\n      157 | });\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:154:40)\\n\\nPASS tests/unit/state-bridge/session-parser.test.ts\\nPASS tests/unit/state-bridge/context-injector.test.ts\\nJest: \\\"global\\\" coverage threshold for branches (80%) not met: 61.36%\\n\\nTest Suites: 1 failed, 2 passed, 3 total\\nTests:       6 failed, 31 passed, 37 total\\nSnapshots:   0 total\\nTime:        0.775 s, estimated 1 s\\nRan all test suites.\\nTest results written to: test-results.json\\n\", \"stderr\": \"sh: 1: Bad substitution\\n\", \"success\": false}"
}