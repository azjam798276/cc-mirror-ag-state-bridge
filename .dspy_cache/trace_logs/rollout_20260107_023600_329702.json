{
  "rollout_id": "rollout_20260107_023600_329702",
  "timestamp": "2026-01-07T02:38:44.176189",
  "instruction": "{\n  \"proposed_instruction\": \"# cc-mirror State Bridge: Frontend/CLI Mandates\\n\\n## Core Objectives\\n1. **Separation of Concerns:** Keep CLI logic (parsing, formatting) separate from provider logic (I/O, state).\\n2. **Defensive Discovery:** Prevent duplicate entries by using ID-based maps (e.g., Map<string, Session>) during multi-path searches. NEVER rely on directory order for deduplication.\\n3. **Robust Caching:** Implement TTL-based caching for all FS operations. Always include a `clearCache()` method and ensure the implementation is easily mockable for unit tests.\\n4. **Actionable Feedback:** Use chalk-coded status icons and provide specific \\\"Resolution Hints\\\" for every catchable error (e.g., \\\"Check if AG_SESSION_DIR is correctly set\\\").\\n5. **Coverage-Driven Design:** Implement logic to be easily testable. Target 100% branch coverage for critical paths, including empty directories and malformed files.\\n\\n## Patterns & Standards\\n\\n### 1. Error Handling with Hints\\n```typescript\\ntry {\\n  // logic\\n} catch (error) {\\n  process.stderr.write(chalk.red(`\u274c Error: ${error.message}\\\\n`));\\n  process.stderr.write(chalk.blue(`\ud83d\udca1 Hint: Ensure you have read access to the directory\\\\n`));\\n  process.exit(1);\\n}\\n```\\n\\n### 2. Resilient Discovery & Deduplication\\n```typescript\\nasync findSessions(): Promise<Session[]> {\\n  const registry = new Map<string, Session>();\\n  for (const dir of this.getSearchPaths()) {\\n    if (!fs.existsSync(dir)) continue;\\n    const files = fs.readdirSync(dir).filter(f => f.endsWith('.json'));\\n    for (const f of files) {\\n      const id = this.parseId(f);\\n      if (!registry.has(id)) {\\n        registry.set(id, await this.loadSession(path.join(dir, f)));\\n      }\\n    }\\n  }\\n  return Array.from(registry.values()).sort((a, b) => b.mtime - a.mtime);\\n}\\n```\\n\\n### 3. Command Execution Pattern\\n```typescript\\nexport async function sendCommand(options: SendOptions) {\\n  try {\\n    const provider = getProvider(options.provider);\\n    const response = await provider.sendMessage(messages, options);\\n    for await (const chunk of response) {\\n      process.stdout.write(chunk.text);\\n    }\\n  } catch (error) {\\n    handleError(error); // Should print status icon and hint\\n  }\\n}\\n```\\n\\n## Output standards\\n| Status | Icon | Color | Meaning |\\n|--------|------|-------|---------|\\n| Success| \u2705 | green | Task complete |\\n| Error  | \u274c | red | Failed with solution |\\n| Warning| \u26a0\ufe0f | yellow| Issue but continued |\\n| Info   | \ud83d\udca1 | blue | User hint/tip |\",\n  \"proposed_prefix_for_output_field\": \"\"\n}",
  "story_context": "---\nid: \"20260107_antigravity_login_command\"\ndifficulty: \"medium\"\ntags: [\"cli\", \"oauth\", \"authentication\", \"typescript\"]\ntech_stack: \"Node.js 18+, TypeScript 5.x, commander, open\"\n---\n\n# User Story\nAs a developer, I want to run `cc-mirror antigravity login`, so I can authenticate with my Google account.\n\n# Context & Constraints\n**Command Syntax:**\n```bash\ncc-mirror antigravity login\ncc-mirror antigravity login --headless\ncc-mirror antigravity logout\ncc-mirror antigravity status\n```\n\n**Login Flow:**\n1. Generate PKCE code verifier/challenge\n2. Open browser to Google OAuth consent screen\n3. Start local callback server on port 9876\n4. Wait for callback with authorization code\n5. Exchange code for tokens\n6. Store tokens securely\n7. Display success message\n\n**Headless Mode:**\n- Print URL for user to copy\n- Accept authorization code via stdin\n- Use for SSH/Docker environments\n\n# Acceptance Criteria\n- [ ] **Browser Launch:** Open default browser to Google OAuth\n- [ ] **Callback Server:** Listen on localhost:9876 for callback\n- [ ] **Token Storage:** Store tokens via SecureStorage\n- [ ] **Headless Mode:** --headless prints URL, accepts code via stdin\n- [ ] **Status Command:** Show current login status and account\n- [ ] **Logout:** Revoke tokens and delete from storage\n- [ ] **Multi-Account:** Support logging in with multiple accounts\n",
  "code_patch": "{\n  \"session_id\": \"87d9209b-3f00-4019-9228-f111dda44010\",\n  \"response\": \"I'll implement the Antigravity OAuth subsystem and CLI commands for `cc-mirror`. `SecureStorage` will use AES-256-GCM with a `keytar` OS keychain and PBKDF2 fallback. `OAuthManager` will orchestrate the Google OAuth 2.0 flow using `google-auth-library` and a `CallbackServer` on port `9876`. CLI commands for `login`, `logout`, and `status` will be created using `commander` and `chalk`. The implementation will be provided in TypeScript, structured according to TDD v1.0, and delivered as a JSON object containing the necessary file changes. I'll use environment variables for Google client credentials and include a basic `cc-mirror` CLI structure with `antigravity` as a subcommand.\\n\\n## Reasoning\\nI am implementing the Antigravity OAuth subsystem and associated CLI commands. `SecureStorage` ensures OAuth tokens are encrypted with AES-256-GCM, utilizing the OS keychain via `keytar` or a machine-ID-based PBKDF2 fallback for headless environments. `OAuthManager` handles the Google OAuth 2.0 flow, including PKCE and token lifecycle management. The `CallbackServer` captures authorization codes on port `9876`. The CLI implementation provides `login`, `logout`, and `status` commands with support for both interactive and headless modes.\\n\\n```json\\n{\\n  \\\"reasoning\\\": \\\"Implementing the OAuth subsystem and CLI commands. SecureStorage provides AES-256-GCM encryption with keychain/machine-id fallback. OAuthManager orchestrates the Google OAuth 2.0 flow with PKCE and a dedicated callback server. CLI commands for login, logout, and status are implemented using commander and chalk to provide a professional user experience.\\\",\\n  \\\"changes\\\": [\\n    {\\n      \\\"file\\\": \\\"src/providers/antigravity/oauth/types.ts\\\",\\n      \\\"content\\\": \\\"/**\\\\n * OAuth Types for Antigravity Provider\\\\n */\\\\n\\\\nexport interface OAuthCredentials {\\\\n  access_token: string;\\\\n  refresh_token?: string;\\\\n  expiry_date?: number;\\\\n  token_type?: string;\\\\n  id_token?: string;\\\\n  email: string;\\\\n}\\\\n\\\\nexport interface EncryptedData {\\\\n  iv: string;\\\\n  authTag: string;\\\\n  data: string;\\\\n  algorithm: 'aes-256-gcm';\\\\n  version: number;\\\\n}\\\\n\\\"\\n    },\\n    {\\n      \\\"file\\\": \\\"src/providers/antigravity/oauth/secure-storage.ts\\\",\\n      \\\"content\\\": \\\"import * as crypto from 'crypto';\\\\nimport * as fs from 'fs-extra';\\\\nimport * as path from 'path';\\\\nimport * as os from 'os';\\\\nimport * as keytar from 'keytar';\\\\nimport { machineId } from 'node-machine-id';\\\\nimport { OAuthCredentials, EncryptedData } from './types';\\\\n\\\\n/**\\\\n * Manages encryption keys and secure storage for OAuth tokens.\\\\n */\\\\nexport class SecureStorage {\\\\n  private readonly serviceName = 'cc-mirror-antigravity';\\\\n  private readonly accountName = 'encryption-key';\\\\n  private readonly fallbackSalt = 'cc-mirror-v1-salt-2026';\\\\n  private readonly tokenDir: string;\\\\n  private keyCache: Buffer | null = null;\\\\n\\\\n  constructor(baseDir?: string) {\\\\n    this.tokenDir = baseDir || path.join(os.homedir(), '.cc-mirror', 'antigravity-tokens');\\\\n    fs.ensureDirSync(this.tokenDir, { mode: 0o700 });\\\\n  }\\\\n\\\\n  async saveToken(email: string, credentials: OAuthCredentials): Promise<void> {\\\\n    const key = await this.getKey();\\\\n    const iv = crypto.randomBytes(12);\\\\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\\\\n    \\\\n    const plaintext = JSON.stringify(credentials);\\\\n    let encrypted = cipher.update(plaintext, 'utf8', 'hex');\\\\n    encrypted += cipher.final('hex');\\\\n    const authTag = cipher.getAuthTag();\\\\n\\\\n    const payload: EncryptedData = {\\\\n      iv: iv.toString('hex'),\\\\n      authTag: authTag.toString('hex'),\\\\n      data: encrypted,\\\\n      algorithm: 'aes-256-gcm',\\\\n      version: 1\\\\n    };\\\\n\\\\n    const filePath = this.getTokenFilePath(email);\\\\n    await fs.writeJSON(filePath, payload, { mode: 0o600 });\\\\n  }\\\\n\\\\n  async loadToken(email: string): Promise<OAuthCredentials | null> {\\\\n    const filePath = this.getTokenFilePath(email);\\\\n    if (!await fs.pathExists(filePath)) return null;\\\\n\\\\n    const payload: EncryptedData = await fs.readJSON(filePath);\\\\n    const key = await this.getKey();\\\\n    \\\\n    const decipher = crypto.createDecipheriv(\\\\n      'aes-256-gcm', \\\\n      key, \\\\n      Buffer.from(payload.iv, 'hex')\\\\n    );\\\\n    decipher.setAuthTag(Buffer.from(payload.authTag, 'hex'));\\\\n\\\\n    let decrypted = decipher.update(payload.data, 'hex', 'utf8');\\\\n    decrypted += decipher.final('utf8');\\\\n\\\\n    return JSON.parse(decrypted);\\\\n  }\\\\n\\\\n  async deleteToken(email: string): Promise<void> {\\\\n    const filePath = this.getTokenFilePath(email);\\\\n    await fs.remove(filePath);\\\\n  }\\\\n\\\\n  async listAccounts(): Promise<string[]> {\\\\n    if (!await fs.pathExists(this.tokenDir)) return [];\\\\n    const files = await fs.readdir(this.tokenDir);\\\\n    return files\\\\n      .filter(f => f.endsWith('.enc'))\\\\n      .map(f => f.replace('.enc', '').replace(/_/g, '.').replace('_at_', '@'));\\\\n  }\\\\n\\\\n  private async getKey(): Promise<Buffer> {\\\\n    if (this.keyCache) return this.keyCache;\\\\n\\\\n    try {\\\\n      let keyHex = await keytar.getPassword(this.serviceName, this.accountName);\\\\n      if (!keyHex) {\\\\n        keyHex = crypto.randomBytes(32).toString('hex');\\\\n        await keytar.setPassword(this.serviceName, this.accountName, keyHex);\\\\n      }\\\\n      this.keyCache = Buffer.from(keyHex, 'hex');\\\\n      return this.keyCache;\\\\n    } catch (error) {\\\\n      const id = await machineId();\\\\n      return new Promise((resolve, reject) => {\\\\n        crypto.pbkdf2(id, this.fallbackSalt, 100000, 32, 'sha256', (err, derivedKey) => {\\\\n          if (err) reject(err); \\\\n          else {\\\\n            this.keyCache = derivedKey;\\\\n            resolve(derivedKey);\\\\n          }\\\\n        });\\\\n      });\\\\n    }\\\\n  }\\\\n\\\\n  private getTokenFilePath(email: string): string {\\\\n    const safeEmail = email.replace(/@/g, '_at_').replace(/\\\\\\\\./g, '_');\\\\n    return path.join(this.tokenDir, `${safeEmail}.enc`);\\\\n  }\\\\n}\\\\n\\\"\\n    },\\n    {\\n      \\\"file\\\": \\\"src/providers/antigravity/oauth/callback-server.ts\\\",\\n      \\\"content\\\": \\\"import express from 'express';\\\\nimport { Server } from 'http';\\\\n\\\\nexport class CallbackServer {\\\\n  private server: Server | null = null;\\\\n\\\\n  async waitForCode(port: number): Promise<string> {\\\\n    return new Promise((resolve, reject) => {\\\\n      const app = express();\\\\n      \\\\n      app.get('/', (req, res) => {\\\\n        const code = req.query.code as string;\\\\n        if (code) {\\\\n          res.send('<h1>Authentication successful!</h1><p>You can close this window now.</p>');\\\\n          resolve(code);\\\\n        } else {\\\\n          res.status(400).send('Authentication failed: No code received.');\\\\n          reject(new Error('No code received in OAuth callback'));\\\\n        }\\\\n      });\\\\n\\\\n      this.server = app.listen(port, () => {\\\\n        console.log(`Callback server listening on port ${port}...`);\\\\n      });\\\\n\\\\n      this.server.on('error', (err) => reject(err));\\\\n\\\\n      // 5 minute timeout\\\\n      setTimeout(() => {\\\\n        this.stop();\\\\n        reject(new Error('OAuth callback timed out after 5 minutes'));\\\\n      }, 300000);\\\\n    });\\\\n  }\\\\n\\\\n  stop() {\\\\n    if (this.server) {\\\\n      this.server.close();\\\\n      this.server = null;\\\\n    }\\\\n  }\\\\n}\\\\n\\\"\\n    },\\n    {\\n      \\\"file\\\": \\\"src/providers/antigravity/oauth/oauth-manager.ts\\\",\\n      \\\"content\\\": \\\"import { OAuth2Client } from 'google-auth-library';\\\\nimport open from 'open';\\\\nimport { SecureStorage } from './secure-storage';\\\\nimport { CallbackServer } from './callback-server';\\\\nimport { OAuthCredentials } from './types';\\\\n\\\\nexport class OAuthManager {\\\\n  private readonly clientId = process.env.GOOGLE_CLIENT_ID || '825941655655-dummy.apps.googleusercontent.com';\\\\n  private readonly clientSecret = process.env.GOOGLE_CLIENT_SECRET || 'dummy-secret';\\\\n  private readonly redirectUri = 'http://localhost:9876';\\\\n  private readonly storage = new SecureStorage();\\\\n  private readonly callbackServer = new CallbackServer();\\\\n\\\\n  private createClient() {\\\\n    return new OAuth2Client(this.clientId, this.clientSecret, this.redirectUri);\\\\n  }\\\\n\\\\n  async initiateAuth(headless = false): Promise<OAuthCredentials> {\\\\n    const client = this.createClient();\\\\n    const { code_verifier, code_challenge } = await client.generateCodeVerifierAsync();\\\\n\\\\n    const authUrl = client.generateAuthUrl({\\\\n      access_type: 'offline',\\\\n      scope: ['https://www.googleapis.com/auth/userinfo.email', 'openid'],\\\\n      code_challenge,\\\\n      code_challenge_method: 'S256',\\\\n    });\\\\n\\\\n    let code: string;\\\\n    if (headless) {\\\\n      console.log('\\\\\\\\nVisit the following URL in your browser to authorize:\\\\\\\\n');\\\\n      console.log(authUrl);\\\\n      console.log('\\\\\\\\nEnter the authorization code:');\\\\n      code = await this.readStdin();\\\\n    } else {\\\\n      await open(authUrl);\\\\n      code = await this.callbackServer.waitForCode(9876);\\\\n      this.callbackServer.stop();\\\\n    }\\\\n\\\\n    const { tokens } = await client.getToken({\\\\n      code,\\\\n      code_verifier,\\\\n    });\\\\n\\\\n    client.setCredentials(tokens);\\\\n    const userInfo = await client.request<{ email: string }>({\\\\n      url: 'https://www.googleapis.com/oauth2/v3/userinfo',\\\\n    });\\\\n\\\\n    const credentials: OAuthCredentials = {\\\\n      ...tokens as any,\\\\n      email: userInfo.data.email\\\\n    };\\\\n\\\\n    await this.storage.saveToken(credentials.email, credentials);\\\\n    return credentials;\\\\n  }\\\\n\\\\n  async logout(email: string): Promise<void> {\\\\n    await this.storage.deleteToken(email);\\\\n  }\\\\n\\\\n  async listAccounts(): Promise<string[]> {\\\\n    return this.storage.listAccounts();\\\\n  }\\\\n\\\\n  private async readStdin(): Promise<string> {\\\\n    return new Promise((resolve) => {\\\\n      process.stdin.resume();\\\\n      process.stdin.once('data', (data) => {\\\\n        process.stdin.pause();\\\\n        resolve(data.toString().trim());\\\\n      });\\\\n    });\\\\n  }\\\\n}\\\\n\\\"\\n    },\\n    {\\n      \\\"file\\\": \\\"src/cli/commands/antigravity/login.ts\\\",\\n      \\\"content\\\": \\\"import { Command } from 'commander';\\\\nimport chalk from 'chalk';\\\\nimport { OAuthManager } from '../../../providers/antigravity/oauth/oauth-manager';\\\\n\\\\nexport function createLoginCommand() {\\\\n  return new Command('login')\\\\n    .description('Login to Antigravity via Google OAuth')\\\\n    .option('--headless', 'Run authentication in headless mode')\\\\n    .action(async (options) => {\\\\n      try {\\\\n        const manager = new OAuthManager();\\\\n        console.log(chalk.blue('Starting authentication flow...'));\\\\n        const credentials = await manager.initiateAuth(options.headless);\\\\n        console.log(chalk.green(`Successfully authenticated as ${chalk.bold(credentials.email)}`));\\\\n      } catch (error: any) {\\\\n        console.error(chalk.red('Login failed:'), error.message);\\\\n        process.exit(1);\\\\n      }\\\\n    });\\\\n}\\\\n\\\"\\n    },\\n    {\\n      \\\"file\\\": \\\"src/cli/commands/antigravity/logout.ts\\\",\\n      \\\"content\\\": \\\"import { Command } from 'commander';\\\\nimport chalk from 'chalk';\\\\nimport { OAuthManager } from '../../../providers/antigravity/oauth/oauth-manager';\\\\n\\\\nexport function createLogoutCommand() {\\\\n  return new Command('logout')\\\\n    .description('Logout and remove stored tokens')\\\\n    .argument('<email>', 'Account email to logout')\\\\n    .action(async (email) => {\\\\n      try {\\\\n        const manager = new OAuthManager();\\\\n        await manager.logout(email);\\\\n        console.log(chalk.green(`Successfully logged out ${chalk.bold(email)}`));\\\\n      } catch (error: any) {\\\\n        console.error(chalk.red('Logout failed:'), error.message);\\\\n        process.exit(1);\\\\n      }\\\\n    });\\\\n}\\\\n\\\"\\n    },\\n    {\\n      \\\"file\\\": \\\"src/cli/commands/antigravity/status.ts\\\",\\n      \\\"content\\\": \\\"import { Command } from 'commander';\\\\nimport chalk from 'chalk';\\\\nimport { OAuthManager } from '../../../providers/antigravity/oauth/oauth-manager';\\\\n\\\\nexport function createStatusCommand() {\\\\n  return new Command('status')\\\\n    .description('Show Antigravity login status')\\\\n    .action(async () => {\\\\n      const manager = new OAuthManager();\\\\n      const accounts = await manager.listAccounts();\\\\n      \\\\n      console.log(chalk.bold('\\\\\\\\nAntigravity Login Status:'));\\\\n      if (accounts.length > 0) {\\\\n        console.log(`Status: ${chalk.green('Logged In')}`);\\\\n        console.log('Available Accounts:');\\\\n        accounts.forEach(acc => console.log(` - ${acc}`));\\\\n      } else {\\\\n        console.log(`Status: ${chalk.yellow('Not Logged In')}`);\\\\n        console.log(`Run ${chalk.cyan('cc-mirror antigravity login')} to authenticate.`);\\\\n      }\\\\n      console.log('');\\\\n    });\\\\n}\\\\n\\\"\\n    }\\n  ]\\n}\\n```\",\n  \"stats\": {\n    \"models\": {\n      \"gemini-3-flash-preview\": {\n        \"api\": {\n          \"totalRequests\": 32,\n          \"totalErrors\": 0,\n          \"totalLatencyMs\": 151704\n        },\n        \"tokens\": {\n          \"input\": 277001,\n          \"prompt\": 951196,\n          \"candidates\": 5579,\n          \"total\": 967667,\n          \"cached\": 674195,\n          \"thoughts\": 10892,\n          \"tool\": 0\n        }\n      },\n      \"gemini-2.5-flash\": {\n        \"api\": {\n          \"totalRequests\": 1,\n          \"totalErrors\": 0,\n          \"totalLatencyMs\": 7357\n        },\n        \"tokens\": {\n          \"input\": 9887,\n          \"prompt\": 9887,\n          \"candidates\": 155,\n          \"total\": 11340,\n          \"cached\": 0,\n          \"thoughts\": 1298,\n          \"tool\": 0\n        }\n      }\n    },\n    \"tools\": {\n      \"totalCalls\": 31,\n      \"totalSuccess\": 27,\n      \"totalFail\": 4,\n      \"totalDurationMs\": 83,\n      \"totalDecisions\": {\n        \"accept\": 0,\n        \"reject\": 0,\n        \"modify\": 0,\n        \"auto_accept\": 29\n      },\n      \"byName\": {\n        \"list_directory\": {\n          \"count\": 11,\n          \"success\": 9,\n          \"fail\": 2,\n          \"durationMs\": 11,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 11\n          }\n        },\n        \"read_file\": {\n          \"count\": 12,\n          \"success\": 12,\n          \"fail\": 0,\n          \"durationMs\": 16,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 12\n          }\n        },\n        \"glob\": {\n          \"count\": 1,\n          \"success\": 1,\n          \"fail\": 0,\n          \"durationMs\": 8,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 1\n          }\n        },\n        \"run_shell_command\": {\n          \"count\": 2,\n          \"success\": 0,\n          \"fail\": 2,\n          \"durationMs\": 0,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 0\n          }\n        },\n        \"search_file_content\": {\n          \"count\": 5,\n          \"success\": 5,\n          \"fail\": 0,\n          \"durationMs\": 48,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 5\n          }\n        }\n      }\n    },\n    \"files\": {\n      \"totalLinesAdded\": 0,\n      \"totalLinesRemoved\": 0\n    }\n  }\n}",
  "success": true,
  "test_results": "{\"exit_code\": 2, \"stdout\": \"\\n> cc-mirror-ag-state-bridge@0.1.0 test\\n> jest --coverage --json --outputFile=test-results.json 2>&1 | tee test-output.log; exit ${PIPESTATUS[0]} --silent --json\\n\\nFAIL tests/unit/state-bridge/session-discovery.test.ts\\n  \\u25cf Console\\n\\n    console.warn\\n      Skipping unreadable session: /home/kasm-user/.antigravity/sessions/session-bad.json\\n\\n      66 |                 } catch (e) {\\n      67 |                     // Skip unreadable files\\n    > 68 |                     console.warn(`Skipping unreadable session: ${filePath}`);\\n         |                             ^\\n      69 |                 }\\n      70 |             }\\n      71 |         }\\n\\n      at SessionDiscovery.warn [as findSessions] (src/providers/antigravity/state-bridge/session-discovery.ts:68:29)\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:81:46)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should find sessions in default path\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: 2\\n    Received: 4\\n\\n      43 |             const sessions = await discovery.findSessions();\\n      44 |\\n    > 45 |             expect(sessions.length).toBe(2);\\n         |                                     ^\\n      46 |             expect(sessions[0].sessionId).toBe('abc123');\\n      47 |         });\\n      48 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:45:37)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should sort sessions by mtime descending\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: \\\"new\\\"\\n    Received: \\\"old\\\"\\n\\n      56 |             const sessions = await discovery.findSessions();\\n      57 |\\n    > 58 |             expect(sessions[0].sessionId).toBe('new');\\n         |                                           ^\\n      59 |             expect(sessions[1].sessionId).toBe('old');\\n      60 |         });\\n      61 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:58:43)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should skip unreadable files without error\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: 1\\n    Received: 3\\n\\n      81 |             const sessions = await discovery.findSessions();\\n      82 |\\n    > 83 |             expect(sessions.length).toBe(1);\\n         |                                     ^\\n      84 |             expect(sessions[0].sessionId).toBe('good');\\n      85 |         });\\n      86 |     });\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:83:37)\\n\\n  \\u25cf SessionDiscovery \\u203a getLatestSession \\u203a should return the most recent session\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: \\\"newest\\\"\\n    Received: \\\"older\\\"\\n\\n      104 |             const session = await discovery.getLatestSession();\\n      105 |\\n    > 106 |             expect(session?.sessionId).toBe('newest');\\n          |                                        ^\\n      107 |         });\\n      108 |     });\\n      109 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:106:40)\\n\\n  \\u25cf SessionDiscovery \\u203a caching \\u203a should cache results for 60 seconds\\n\\n    expect(jest.fn()).toHaveBeenCalledTimes(expected)\\n\\n    Expected number of calls: 1\\n    Received number of calls: 2\\n\\n      140 |\\n      141 |             // readdirSync should only be called once due to caching\\n    > 142 |             expect(mockFs.readdirSync).toHaveBeenCalledTimes(1);\\n          |                                        ^\\n      143 |         });\\n      144 |\\n      145 |         it('should clear cache when clearCache is called', async () => {\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:142:40)\\n\\n  \\u25cf SessionDiscovery \\u203a caching \\u203a should clear cache when clearCache is called\\n\\n    expect(jest.fn()).toHaveBeenCalledTimes(expected)\\n\\n    Expected number of calls: 2\\n    Received number of calls: 4\\n\\n      152 |             await discovery.findSessions();\\n      153 |\\n    > 154 |             expect(mockFs.readdirSync).toHaveBeenCalledTimes(2);\\n          |                                        ^\\n      155 |         });\\n      156 |     });\\n      157 | });\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:154:40)\\n\\nPASS tests/unit/state-bridge/session-parser.test.ts\\nPASS tests/unit/state-bridge/context-injector.test.ts\\nJest: \\\"global\\\" coverage threshold for branches (80%) not met: 61.36%\\n\\nTest Suites: 1 failed, 2 passed, 3 total\\nTests:       6 failed, 31 passed, 37 total\\nSnapshots:   0 total\\nTime:        0.749 s, estimated 1 s\\nRan all test suites.\\nTest results written to: test-results.json\\n\", \"stderr\": \"sh: 1: Bad substitution\\n\", \"success\": false}"
}