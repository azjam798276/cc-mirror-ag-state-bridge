{
  "rollout_id": "rollout_20260107_021742_226698",
  "timestamp": "2026-01-07T02:19:03.613659",
  "instruction": "# Backend Engineering: cc-mirror State Bridge Adapter\n\n## Core Mandates\n1. **Deduplicated Lazy Discovery:** `SessionDiscovery` MUST only use `fs.stat` for metadata. You MUST use a `Map<string, AGSessionMetadata>` keyed by `sessionId` to deduplicate results across all search paths. If a session exists in multiple paths, retain ONLY the entry with the most recent `mtime`.\n2. **Resilient Tiered Parsing:** Implement a multi-stage parser (V1 -> V2 -> Generic Heuristic). The Generic parser MUST use depth-limited recursive search (max depth 3) to find `goal`, `steps`, and `files` keys in unknown JSON. Never crash on malformed JSON; return partial context if possible.\n3. **Token-First Context Injection:** Strictly enforce a 12.5K token (~50KB) budget. Use a \"Recency-First\" truncation strategy: prioritize the Goal and Files list; truncate or summarize older Plan Steps first if the budget is exceeded.\n4. **Platform-Aware Path Resolution:** Respect `$AG_SESSION_DIR` as highest priority. Defaults MUST follow platform standards (Linux: `~/.config`, macOS: `Library/Application Support`, Windows: `%APPDATA%`). Use `path.join()` and `os.homedir()` for portability.\n5. **OAuth & Secure Storage:** Implement OAuth 2.0 flow via `google-auth-library` with an `express` callback listener. Encrypt tokens using AES-256-GCM and store keys in the OS keychain via `keytar`.\n\n## Standards & Quality\n- **Coverage & Testing:** Maintain >90% branch coverage with `jest`. Rigorously mock `fs-extra` and `process.platform` to test overlapping search paths and cross-platform behavior. Ensure `SessionDiscovery` caching logic accounts for multiple initial directory scans.\n- **Latency (p90):** Discovery < 50ms, Parsing < 100ms, Injection < 20ms.\n- **Protocol:** Map roles (`user` -> `user`, `assistant` -> `model`) and consolidate system context into a single `systemInstruction` field.\n- **Tool Hardening:** Apply the 4-layer Mirrowel pattern for all tool definitions.",
  "story_context": "---\nid: \"20260107_session_parser\"\ndifficulty: \"hard\"\ntags: [\"state-bridge\", \"parsing\", \"json\", \"typescript\", \"resilience\"]\ntech_stack: \"Node.js 18+, TypeScript 5.x\"\n---\n\n# User Story\nAs a developer, I want cc-mirror to parse Antigravity session files reliably, so I can get my work context even if AG's format changes.\n\n# Context & Constraints\n**Interface Requirements (SessionParser):**\n```typescript\ninterface SessionParser {\n  parse(filePath: string): Promise<ParsedSession>;\n  registerFormat(detector: FormatDetector): void;\n}\n\ninterface ParsedSession {\n  sessionId: string;\n  goal: string;\n  planSteps: PlanStep[];\n  currentStep: number;\n  completedSteps: PlanStep[];\n  pendingSteps: PlanStep[];\n  filesModified: string[];\n  variables: Record<string, any>;\n}\n\ninterface PlanStep {\n  id: string;\n  action: string;\n  status: 'pending' | 'executing' | 'completed' | 'failed';\n  artifacts?: string[];\n}\n```\n\n**Format Detection Strategy:**\n1. Try known format v1 (legacy)\n2. Try known format v2 (current)\n3. Fallback to generic heuristic parser\n\n**Constraints:**\n| Constraint | Threshold |\n|------------|-----------|\n| Max file size | 50MB (throw error) |\n| Parse time (<1MB) | < 100ms |\n| Recursion depth (generic) | 3 levels |\n\n# Acceptance Criteria\n- [ ] **Format v1:** Parse `{ initialPrompt, plan[], status }` structure\n- [ ] **Format v2:** Parse `{ goal, steps[], execution }` structure\n- [ ] **Generic Fallback:** Extract goal/steps using heuristic field search\n- [ ] **Size Guard:** Throw `SessionParseError` for files > 50MB\n- [ ] **Malformed JSON:** Throw `SessionParseError` with line number\n- [ ] **Partial Success:** Extract what's possible, fill missing with defaults\n- [ ] **Extensible:** Allow registering new format detectors at runtime\n",
  "code_patch": "{\n  \"session_id\": \"0c908e5c-36e7-43ad-9fcd-b38e3e933130\",\n  \"response\": \"Reasoning:\\nThe implementation of `SessionParser` has been refined to meet all the requirements specified in the User Story and Technical Design Documents. Key improvements include:\\n1.  **Size Guarding**: Integrated a 50MB file size limit check using `fs.statSync` before attempting to read or parse files, preventing memory exhaustion.\\n2.  **Resilient Tiered Parsing**: Maintained the V1 -> V2 -> Generic fallback strategy. `V1FormatDetector` and `V2FormatDetector` now more accurately target their respective AG session structures, while `GenericFormatDetector` serves as a robust last resort.\\n3.  **Improved JSON Error Reporting**: Enhanced the `JSON.parse` catch block to extract the failure position and convert it into a line number, providing much more actionable error messages for malformed session files.\\n4.  **Depth-Limited Heuristic Search**: The `GenericFormatDetector` now strictly enforces a `MAX_RECURSION_DEPTH` of 3 when searching for `goal`, `steps`, and `files`, preventing performance issues on deeply nested or large unknown objects.\\n5.  **Partial Data Extraction**: All detectors are designed to be \\\"best-effort,\\\" using defaults (e.g., 'Unknown goal', empty arrays) when specific fields are missing, ensuring cc-mirror can still provide some context even from incomplete sessions.\\n6.  **Runtime Extensibility**: The `registerFormat` method allows for the dynamic addition of new format detectors, ensuring the parser can adapt to future Antigravity format changes without core logic modifications.\\n\\n```json\\n[\\n  {\\n    \\\"file\\\": \\\"src/providers/antigravity/state-bridge/session-parser.ts\\\",\\n    \\\"operation\\\": \\\"replace\\\",\\n    \\\"content\\\": \\\"/**\\\\n * SessionParser - Parse AG session JSON files\\\\n * Based on TDD v1.0 Module 2 specification and PRD v2.0\\\\n */\\\\n\\\\nimport * as fs from 'fs-extra';\\\\nimport { ParsedSession, PlanStep, FormatDetector, SessionParseError } from './types';\\\\n\\\\nconst MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB\\\\nconst MAX_RECURSION_DEPTH = 3;\\\\n\\\\nexport class SessionParser {\\\\n    private formatDetectors: FormatDetector[] = [];\\\\n\\\\n    constructor() {\\\\n        // Register built-in format detectors in priority order\\\\n        this.formatDetectors.push(new V1FormatDetector());\\\\n        this.formatDetectors.push(new V2FormatDetector());\\\\n        this.formatDetectors.push(new GenericFormatDetector());\\\\n    }\\\\n\\\\n    async parse(filePath: string): Promise<ParsedSession> {\\\\n        // Check file size (Size Guard)\\\\n        try {\\\\n            const stats = fs.statSync(filePath);\\\\n            if (stats.size > MAX_FILE_SIZE) {\\\\n                throw new SessionParseError(`File exceeds 50MB limit: ${Math.round(stats.size / 1024 / 1024)}MB`, filePath);\\\\n            }\\\\n        } catch (e: any) {\\\\n            if (e instanceof SessionParseError) throw e;\\\\n            throw new SessionParseError(`Could not access file: ${e.message}`, filePath);\\\\n        }\\\\n\\\\n        // Read content\\\\n        let content: string;\\\\n        try {\\\\n            content = fs.readFileSync(filePath, 'utf-8');\\\\n        } catch (e: any) {\\\\n            throw new SessionParseError(`Failed to read file: ${e.message}`, filePath);\\\\n        }\\\\n\\\\n        // Parse JSON with line number reporting for malformed files\\\\n        let raw: any;\\\\n        try {\\\\n            raw = JSON.parse(content);\\\\n        } catch (e: any) {\\\\n            let lineInfo = '';\\\\n            const posMatch = e.message.match(/position (\\\\\\\\d+)/);\\\\n            if (posMatch) {\\\\n                const pos = parseInt(posMatch[1], 10);\\\\n                const line = content.slice(0, pos).split('\\\\\\\\n').length;\\\\n                lineInfo = ` at line ${line}`;\\\\n            }\\\\n            throw new SessionParseError(`Malformed JSON${lineInfo}: ${e.message}`, filePath);\\\\n        }\\\\n\\\\n        // Tiered Parsing: Try each format detector\\\\n        for (const detector of this.formatDetectors) {\\\\n            if (detector.canParse(raw)) {\\\\n                try {\\\\n                    return detector.parse(raw);\\\\n                } catch (e: any) {\\\\n                    // If a specific detector fails, log and continue to next/fallback\\\\n                    console.error(`Detector failed for ${filePath}: ${e.message}`);\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        // Fallback is handled by GenericFormatDetector which always returns true for canParse\\\\n        throw new SessionParseError('No format detector could parse the session', filePath);\\\\n    }\\\\n\\\\n    registerFormat(detector: FormatDetector): void {\\\\n        // Insert before generic detector (which is always last)\\\\n        this.formatDetectors.splice(this.formatDetectors.length - 1, 0, detector);\\\\n    }\\\\n}\\\\n\\\\nclass V1FormatDetector implements FormatDetector {\\\\n    canParse(obj: any): boolean {\\\\n        return obj && typeof obj === 'object' && obj.hasOwnProperty('initialPrompt') && obj.hasOwnProperty('plan');\\\\n    }\\\\n\\\\n    parse(obj: any): ParsedSession {\\\\n        const planSteps: PlanStep[] = (obj.plan || []).map((step: any) => ({\\\\n            id: step.id || step.stepId || '',\\\\n            action: step.description || step.action || '',\\\\n            status: this.normalizeStatus(step.status),\\\\n            artifacts: step.files || step.artifacts || []\\\\n        }));\\\\n\\\\n        return {\\\\n            sessionId: obj.sessionId || 'unknown',\\\\n            goal: obj.initialPrompt || obj.goal || 'Unknown goal',\\\\n            planSteps,\\\\n            currentStep: obj.currentStepIndex || 0,\\\\n            completedSteps: planSteps.filter(s => s.status === 'completed'),\\\\n            pendingSteps: planSteps.filter(s => s.status !== 'completed'),\\\\n            filesModified: this.extractFiles(obj),\\\\n            variables: obj.state?.variables || obj.variables || {}\\\\n        };\\\\n    }\\\\n\\\\n    private normalizeStatus(status: string): PlanStep['status'] {\\\\n        const statusMap: Record<string, PlanStep['status']> = {\\\\n            'completed': 'completed', 'done': 'completed', 'success': 'completed',\\\\n            'executing': 'executing', 'in_progress': 'executing', 'active': 'executing',\\\\n            'pending': 'pending', 'waiting': 'pending',\\\\n            'failed': 'failed', 'error': 'failed'\\\\n        };\\\\n        return statusMap[status?.toLowerCase()] || 'pending';\\\\n    }\\\\n\\\\n    private extractFiles(obj: any): string[] {\\\\n        const files = new Set<string>();\\\\n        for (const step of obj.plan || []) {\\\\n            if (Array.isArray(step.files)) step.files.forEach((f: any) => typeof f === 'string' && files.add(f));\\\\n            if (Array.isArray(step.artifacts)) step.artifacts.forEach((f: any) => typeof f === 'string' && files.add(f));\\\\n        }\\\\n        return [...files];\\\\n    }\\\\n}\\\\n\\\\nclass V2FormatDetector implements FormatDetector {\\\\n    canParse(obj: any): boolean {\\\\n        return obj && typeof obj === 'object' && obj.hasOwnProperty('goal') && obj.hasOwnProperty('steps') && obj.hasOwnProperty('execution');\\\\n    }\\\\n\\\\n    parse(obj: any): ParsedSession {\\\\n        const planSteps: PlanStep[] = (obj.steps || []).map((step: any) => ({\\\\n            id: step.stepId || step.id || '',\\\\n            action: step.action || step.description || '',\\\\n            status: this.normalizePhase(step.phase),\\\\n            artifacts: step.artifacts || []\\\\n        }));\\\\n\\\\n        const completedIds = obj.execution?.completed || [];\\\\n        \\\\n        return {\\\\n            sessionId: obj.sessionId || 'unknown',\\\\n            goal: obj.goal || 'Unknown goal',\\\\n            planSteps,\\\\n            currentStep: planSteps.findIndex(s => s.id === obj.execution?.current) || 0,\\\\n            completedSteps: planSteps.filter(s => completedIds.includes(s.id) || s.status === 'completed'),\\\\n            pendingSteps: planSteps.filter(s => !completedIds.includes(s.id) && s.status !== 'completed'),\\\\n            filesModified: Array.isArray(obj.filesModified) ? obj.filesModified : [],\\\\n            variables: obj.variables || {}\\\\n        };\\\\n    }\\\\n\\\\n    private normalizePhase(phase: string): PlanStep['status'] {\\\\n        const phaseMap: Record<string, PlanStep['status']> = {\\\\n            'done': 'completed', 'completed': 'completed',\\\\n            'running': 'executing', 'active': 'executing',\\\\n            'pending': 'pending',\\\\n            'failed': 'failed'\\\\n        };\\\\n        return phaseMap[phase?.toLowerCase()] || 'pending';\\\\n    }\\\\n}\\\\n\\\\nclass GenericFormatDetector implements FormatDetector {\\\\n    canParse(_obj: any): boolean {\\\\n        return true; // Catch-all fallback\\\\n    }\\\\n\\\\n    parse(obj: any): ParsedSession {\\\\n        const goal = this.findFieldHeuristic(obj, ['goal', 'task', 'prompt', 'initialPrompt', 'request', 'objective'], 'Unknown goal');\\\\n        const steps = this.extractStepsGeneric(obj);\\\\n        const files = this.findFilesHeuristic(obj);\\\\n\\\\n        return {\\\\n            sessionId: obj.sessionId || 'unknown',\\\\n            goal,\\\\n            planSteps: steps,\\\\n            currentStep: 0,\\\\n            completedSteps: steps.filter(s => s.status === 'completed'),\\\\n            pendingSteps: steps.filter(s => s.status !== 'completed'),\\\\n            filesModified: files,\\\\n            variables: obj.variables || obj.state || {}\\\\n        };\\\\n    }\\\\n\\\\n    private findFieldHeuristic(obj: any, keys: string[], defaultValue: string, depth = 0): string {\\\\n        if (depth > MAX_RECURSION_DEPTH || !obj || typeof obj !== 'object') return defaultValue;\\\\n\\\\n        for (const key of keys) {\\\\n            if (typeof obj[key] === 'string') return obj[key];\\\\n        }\\\\n\\\\n        for (const key in obj) {\\\\n            if (typeof obj[key] === 'object') {\\\\n                const result = this.findFieldHeuristic(obj[key], keys, defaultValue, depth + 1);\\\\n                if (result !== defaultValue) return result;\\\\n            }\\\\n        }\\\\n\\\\n        return defaultValue;\\\\n    }\\\\n\\\\n    private extractStepsGeneric(obj: any): PlanStep[] {\\\\n        const stepKeys = ['steps', 'plan', 'actions', 'tasks'];\\\\n        for (const key of stepKeys) {\\\\n            if (Array.isArray(obj[key])) {\\\\n                return obj[key].map((item: any, i: number) => ({\\\\n                    id: item.id || item.stepId || `step-${i}`,\\\\n                    action: item.action || item.description || item.name || (typeof item === 'string' ? item : `Task ${i}`),\\\\n                    status: (item.done || item.completed || item.status === 'completed') ? 'completed' : 'pending',\\\\n                    artifacts: Array.isArray(item.files) ? item.files : (Array.isArray(item.artifacts) ? item.artifacts : [])\\\\n                }));\\\\n            }\\\\n        }\\\\n        return [];\\\\n    }\\\\n\\\\n    private findFilesHeuristic(obj: any, depth = 0): string[] {\\\\n        if (depth > MAX_RECURSION_DEPTH || !obj || typeof obj !== 'object') return [];\\\\n\\\\n        const fileKeys = ['files', 'filesModified', 'modified', 'artifacts'];\\\\n        for (const key of fileKeys) {\\\\n            if (Array.isArray(obj[key])) return obj[key].filter((f: any) => typeof f === 'string');\\\\n        }\\\\n\\\\n        for (const key in obj) {\\\\n            if (typeof obj[key] === 'object') {\\\\n                const result = this.findFilesHeuristic(obj[key], depth + 1);\\\\n                if (result.length > 0) return result;\\\\n            }\\\\n        }\\\\n\\\\n        return [];\\\\n    }\\\\n}\\\\n\\\"\\n  }\\n]\\n```\",\n  \"stats\": {\n    \"models\": {\n      \"gemini-3-flash-preview\": {\n        \"api\": {\n          \"totalRequests\": 10,\n          \"totalErrors\": 0,\n          \"totalLatencyMs\": 77238\n        },\n        \"tokens\": {\n          \"input\": 76389,\n          \"prompt\": 140482,\n          \"candidates\": 3430,\n          \"total\": 150665,\n          \"cached\": 64093,\n          \"thoughts\": 6753,\n          \"tool\": 0\n        }\n      }\n    },\n    \"tools\": {\n      \"totalCalls\": 11,\n      \"totalSuccess\": 10,\n      \"totalFail\": 1,\n      \"totalDurationMs\": 23,\n      \"totalDecisions\": {\n        \"accept\": 0,\n        \"reject\": 0,\n        \"modify\": 0,\n        \"auto_accept\": 10\n      },\n      \"byName\": {\n        \"read_file\": {\n          \"count\": 8,\n          \"success\": 8,\n          \"fail\": 0,\n          \"durationMs\": 10,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 8\n          }\n        },\n        \"run_shell_command\": {\n          \"count\": 1,\n          \"success\": 0,\n          \"fail\": 1,\n          \"durationMs\": 0,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 0\n          }\n        },\n        \"glob\": {\n          \"count\": 1,\n          \"success\": 1,\n          \"fail\": 0,\n          \"durationMs\": 10,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 1\n          }\n        },\n        \"list_directory\": {\n          \"count\": 1,\n          \"success\": 1,\n          \"fail\": 0,\n          \"durationMs\": 3,\n          \"decisions\": {\n            \"accept\": 0,\n            \"reject\": 0,\n            \"modify\": 0,\n            \"auto_accept\": 1\n          }\n        }\n      }\n    },\n    \"files\": {\n      \"totalLinesAdded\": 0,\n      \"totalLinesRemoved\": 0\n    }\n  }\n}",
  "success": true,
  "test_results": "{\"exit_code\": 2, \"stdout\": \"\\n> cc-mirror-ag-state-bridge@0.1.0 test\\n> jest --coverage --json --outputFile=test-results.json 2>&1 | tee test-output.log; exit ${PIPESTATUS[0]} --silent --json\\n\\nFAIL tests/unit/state-bridge/session-discovery.test.ts\\n  \\u25cf Console\\n\\n    console.warn\\n      Skipping unreadable session: /home/kasm-user/.antigravity/sessions/session-bad.json\\n\\n      66 |                 } catch (e) {\\n      67 |                     // Skip unreadable files\\n    > 68 |                     console.warn(`Skipping unreadable session: ${filePath}`);\\n         |                             ^\\n      69 |                 }\\n      70 |             }\\n      71 |         }\\n\\n      at SessionDiscovery.warn [as findSessions] (src/providers/antigravity/state-bridge/session-discovery.ts:68:29)\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:81:46)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should find sessions in default path\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: 2\\n    Received: 4\\n\\n      43 |             const sessions = await discovery.findSessions();\\n      44 |\\n    > 45 |             expect(sessions.length).toBe(2);\\n         |                                     ^\\n      46 |             expect(sessions[0].sessionId).toBe('abc123');\\n      47 |         });\\n      48 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:45:37)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should sort sessions by mtime descending\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: \\\"new\\\"\\n    Received: \\\"old\\\"\\n\\n      56 |             const sessions = await discovery.findSessions();\\n      57 |\\n    > 58 |             expect(sessions[0].sessionId).toBe('new');\\n         |                                           ^\\n      59 |             expect(sessions[1].sessionId).toBe('old');\\n      60 |         });\\n      61 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:58:43)\\n\\n  \\u25cf SessionDiscovery \\u203a findSessions \\u203a should skip unreadable files without error\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: 1\\n    Received: 3\\n\\n      81 |             const sessions = await discovery.findSessions();\\n      82 |\\n    > 83 |             expect(sessions.length).toBe(1);\\n         |                                     ^\\n      84 |             expect(sessions[0].sessionId).toBe('good');\\n      85 |         });\\n      86 |     });\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:83:37)\\n\\n  \\u25cf SessionDiscovery \\u203a getLatestSession \\u203a should return the most recent session\\n\\n    expect(received).toBe(expected) // Object.is equality\\n\\n    Expected: \\\"newest\\\"\\n    Received: \\\"older\\\"\\n\\n      104 |             const session = await discovery.getLatestSession();\\n      105 |\\n    > 106 |             expect(session?.sessionId).toBe('newest');\\n          |                                        ^\\n      107 |         });\\n      108 |     });\\n      109 |\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:106:40)\\n\\n  \\u25cf SessionDiscovery \\u203a caching \\u203a should cache results for 60 seconds\\n\\n    expect(jest.fn()).toHaveBeenCalledTimes(expected)\\n\\n    Expected number of calls: 1\\n    Received number of calls: 2\\n\\n      140 |\\n      141 |             // readdirSync should only be called once due to caching\\n    > 142 |             expect(mockFs.readdirSync).toHaveBeenCalledTimes(1);\\n          |                                        ^\\n      143 |         });\\n      144 |\\n      145 |         it('should clear cache when clearCache is called', async () => {\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:142:40)\\n\\n  \\u25cf SessionDiscovery \\u203a caching \\u203a should clear cache when clearCache is called\\n\\n    expect(jest.fn()).toHaveBeenCalledTimes(expected)\\n\\n    Expected number of calls: 2\\n    Received number of calls: 4\\n\\n      152 |             await discovery.findSessions();\\n      153 |\\n    > 154 |             expect(mockFs.readdirSync).toHaveBeenCalledTimes(2);\\n          |                                        ^\\n      155 |         });\\n      156 |     });\\n      157 | });\\n\\n      at Object.<anonymous> (tests/unit/state-bridge/session-discovery.test.ts:154:40)\\n\\nPASS tests/unit/state-bridge/session-parser.test.ts\\nPASS tests/unit/state-bridge/context-injector.test.ts\\nJest: \\\"global\\\" coverage threshold for branches (80%) not met: 61.36%\\n\\nTest Suites: 1 failed, 2 passed, 3 total\\nTests:       6 failed, 31 passed, 37 total\\nSnapshots:   0 total\\nTime:        0.755 s, estimated 1 s\\nRan all test suites.\\nTest results written to: test-results.json\\n\", \"stderr\": \"sh: 1: Bad substitution\\n\", \"success\": false}"
}